{"version":3,"sources":["context/index.ts"],"names":[],"mappings":"","file":"index.d.ts","sourcesContent":["/// <reference path=\"files.ts\" />\r\n\r\nimport { IncomingHttpHeaders, ServerHttp2Stream, constants as HTTP_CONST } from 'http2';\r\n\r\n/** HTTP constants */\r\nconst {\r\n\tHTTP2_HEADER_METHOD,\r\n\tHTTP2_HEADER_PATH,\r\n\tHTTP2_HEADER_SCHEME,\r\n\tHTTP2_HEADER_CONTENT_TYPE\r\n}= HTTP_CONST;\r\n\r\n//* Types\r\ntype VoidCallback= (...args: any[])=> void\r\n\r\n/**\r\n * Context file\r\n */\r\nclass Context{\r\n\t// Unlerlining Http2Stream\r\n\treadonly stream: ServerHttp2Stream;\r\n\t/** Incomming headers */\r\n\treadonly headers: IncomingHttpHeaders;\r\n\treadonly flags: number\r\n\t/** Incomming raw headers */\r\n\treadonly rawHeaders: string[];\r\n\r\n\tconstructor(stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number, rawHeaders: string[]){\r\n\t\tthis.stream= stream;\r\n\t\tthis.headers= headers;\r\n\t\tthis.flags= flags;\r\n\t\tthis.rawHeaders= rawHeaders;\r\n\t}\r\n\r\n\t/** If the stream aborted */\r\n\tget aborted(){ return this.stream.aborted }\r\n\t/** If stream closed */\r\n\tget closed(){ return this.stream.closed }\r\n\t/** If desctroyed */\r\n\tget destroyed(){ return this.stream.destroyed }\r\n\t/** If headers sent */\r\n\tget headersSent(){ return this.stream.headersSent }\r\n\t/** Get stream id */\r\n\tget id(){ return this.stream.id; }\r\n\r\n\t/** Get Method */\r\n\tget method(){ return this.headers[HTTP2_HEADER_METHOD] }\r\n\tget path(){ return this.headers[HTTP2_HEADER_PATH] }\r\n\tget scheme(){ return this.headers[HTTP2_HEADER_SCHEME] }\r\n\tget contentType(){ return this.headers[HTTP2_HEADER_CONTENT_TYPE]}\r\n\r\n\t/** Sent header: outbound headers */\r\n\tget sentHeaders(){ return this.stream.sentHeaders; }\r\n\r\n\r\n\t/** Close stream */\r\n\tclose(code?: number){\r\n\t\tthis.stream.close(code);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Stream timeout */\r\n\tsetTimeout(msecs: number, callback?: VoidCallback){ this.stream.setTimeout(msecs, callback); }\r\n\r\n\t\r\n\t/** Listeners on stream */\r\n\ton(event: string|symbol, listener: VoidCallback): this{\r\n\t\tthis.stream.on(event, listener);\r\n\t\treturn this;\r\n\t}\r\n\t/** Listen once */\r\n\tonce(event: string|symbol, listener: VoidCallback): this{\r\n\t\tthis.stream.once(event, listener);\r\n\t\treturn this;\r\n\t}\r\n\t/** Emit event */\r\n\temit(event: string | symbol, ...args: any[]): boolean{\r\n\t\treturn this.stream.emit(event, ...args);\r\n\t}\r\n\t/** Await for event once */\r\n\tawaitOnce(event: string|symbol){\r\n\t\treturn new Promise((res, rej)=>{\r\n\t\t\tthis.stream.once(event, res);\r\n\t\t});\r\n\t}\r\n}"]}